### Trabalho 1 e 2 - NOVA DATA 03/10/25

Entrega: Alterar o astah Conceitual.ash(semana6)
Justificar as escolhas da alteração. Nos termos de volume, de replicação, o que implica usar um ou outra
e em tempo de perfomance das queries. Quanto menos collections e pra determinadas areas do sistema, mais 
performatico sera. 

*O T2 será sobre json das collections.

Balancear algo com pouco replicação e performance.

Losangulo pintado com seta: Composição (Aninhamento)

Losangulo não pintado com seta: Agregação (Referência)

-------------------------------------------------

### Ferramentas
- Usando Mongo ATLAS pra criar o DB 
- Usando o MongoDB Compass pras queries e gerenciar as collections de forma organizada
- Astah para o modelo conceitual

--------------------------------------------------
Download compass: 
```
wget https://downloads.mongodb.com/compass/mongodb-compass_1.46.11_amd64.deb
```

Install compass:
```
sudo dpkg -i mongodb-compass_1.46.11_amd64.deb 
```

connection string:
``` 
mongodb+srv://caiomadeira_db_user:<<passwords>>@caiomadeirabd2.gdjroby.mongodb.net/
```

Ótima pergunta! Essa tela é fundamental. Para o seu trabalho, você tem duas opções principais, mas uma delas é a mais recomendada.

Recomendação Principal: Compass (a Opção Mais Fácil e Visual)
Clique em Compass.

O que é? É o programa com interface gráfica (GUI) oficial do MongoDB. Você baixa e instala no seu computador.

Por que usar?

É visual: Você consegue ver seu banco de dados, suas coleções e seus documentos de forma organizada, como se estivesse usando um gerenciador de arquivos.

Perfeito para o trabalho: Para a tarefa de "popular as Collections", o Compass tem um botão para importar arquivos JSON diretamente, o que é uma mão na roda.

Facilita as consultas: Ele tem uma área para você colar e rodar exatamente as queries que eu te passei. Os resultados aparecem em uma tabela limpa, perfeita para tirar os screenshots que você precisa entregar.

Ajuda a explorar: Você pode clicar nos dados para ver como eles estão estruturados, o que é ótimo para entender o modelo.

Alternativa: Shell (a Opção Direta via Linha de Comando)
Clique em Shell.

O que é? É a interface de linha de comando (mongosh). Você interage com o banco de dados via texto, em um terminal.

Por que usar?

Direto ao ponto: Você pode copiar e colar as minhas queries diretamente no terminal e ver o resultado em texto.

Leve e rápido: Não precisa de uma interface gráfica, é a forma "raiz" de interagir com o MongoDB.

Ponto negativo para o seu caso: Importar os arquivos JSON pode exigir um comando a mais no terminal (mongoimport), e a visualização dos dados não é tão amigável quanto no Compass.

Por que não os outros?
Drivers: Isso é para quando você está criando uma aplicação (em Node.js, Python, Java, etc.) que precisa se conectar ao banco de dados. Não é o seu caso.

MongoDB for VS Code: É uma extensão para o editor de código Visual Studio Code. É útil, mas o Compass é uma ferramenta mais dedicada e completa para o que você precisa fazer.

Atlas SQL: Permite que você use comandos SQL no seu banco de dados NoSQL. Não use isso, pois o objetivo do seu trabalho é justamente aprender a usar a linguagem de consulta nativa do MongoDB (MQL), não SQL.

Conclusão:
Para o seu trabalho, que envolve importar dados e tirar prints dos resultados, clique em Compass. Baixe o programa, instale, e na hora de conectar, ele vai te pedir a "connection string" que o próprio Atlas vai te fornecer. Será a maneira mais simples e eficiente de completar sua tarefa.








conectei, mas eu quero primeiuro cuidar do diagrama e adata-lo pro nao relaciona (mongo)



Mostrar raciocínio
Excelente! É o caminho certo: primeiro modelar, depois implementar. O fato de você já ter o modelo relacional e a estrutura JSON que montamos vai facilitar muito a criação do diagrama no Astah.

A tarefa aqui é "traduzir" os conceitos do MongoDB (collections, documentos embutidos, arrays, referências) para uma notação visual. Como o Astah é focado em UML/modelagem relacional, não haverá um "Diagrama MongoDB" pronto. A melhor abordagem é usar um Diagrama de Classes UML, que é flexível o suficiente para representar essa estrutura.

Aqui está um guia passo a passo de como mapear os conceitos:

Guia para Mapear MongoDB para Diagrama de Classes no Astah
Conceito do MongoDB	Como representar no Astah (Diagrama de Classes)
Collection	Uma Classe. Crie uma classe para Pessoas, Equipes, Provas e Campeonatos.
Campos Simples	Atributos dentro da Classe. Ex: na classe Equipes, adicione os atributos nome: string, cidade_sede: string.
Documento Embutido	Uma Classe separada ligada por uma Composição (Composition). A composição (losango preto ◆) significa "faz parte de".
Array de Documentos Embutidos	O mesmo que acima, mas com cardinalidade * na ponta da seta. Ex: "um Campeonato tem 0..* Edicoes".
Referência (ID)	Uma Associação (Association) ou Dependência (Dependency). A seta tracejada --> é ótima para isso.

Exportar para as Planilhas
Exemplo Prático: Modelando a Collection Campeonatos (a mais complexa)
Vamos usar as regras acima para modelar a estrutura aninhada que definimos.

1. Crie as Classes Principais:

Crie uma caixa de Classe chamada Campeonatos.

Adicione seus atributos simples: _id: ObjectId, nome: string.

Faça o mesmo para Pessoas, Equipes e Provas.

2. Modele a Estrutura Embutida (Ninho):

Crie uma nova Classe chamada Edicao. Adicione os atributos dela (ano: int, cidade_sede: string, etc.).

Use a ferramenta de Composição (a linha com o losango preenchido na ponta) para ligar Campeonatos a Edicao.

Clique na linha da associação e defina a cardinalidade: 1 no lado do Campeonatos e 0..* no lado da Edicao. Isso significa: "Um Campeonato é composto por zero ou mais Edições".

Continue esse processo para baixo:

Crie a classe ProvaDisputada.

Crie a classe Bateria.

Crie a classe Resultado.

Ligue Edicao ◆---- 0..* ProvaDisputada.

Ligue ProvaDisputada ◆---- 0..* Bateria.

Ligue Bateria ◆---- 0..* Resultado.

3. Modele as Referências (Links entre Collections):

Dentro da sua classe ProvaDisputada, há o campo recorde, que por sua vez tem um nadador_id.

Adicione o atributo nadador_id: ObjectId na classe que representa o recorde (você pode criar uma classe Recorde e ligá-la por composição a ProvaDisputada).

Agora, use a ferramenta de Dependência (a linha tracejada com uma seta -->) para ligar a classe Recorde à classe Pessoas.

Para ser ainda mais claro, você pode adicionar um "estereótipo" <<references>> no meio da linha tracejada para indicar que é uma referência de ID.

Faça o mesmo para outras referências:

De Resultado ----> para Pessoas (para o nadador_id).

De Pessoas ----> para Equipes (para o equipe_id).

Como Ficará a Estrutura Visual (Resumo)
Passos a seguir no Astah:

Abra o Astah e crie um novo Diagrama de Classes.

Crie as 4 classes principais para suas 4 collections: Campeonatos, Pessoas, Equipes, Provas.

Crie as classes "auxiliares" que representarão os documentos embutidos: Edicao, ProvaDisputada, Bateria, Resultado, Recorde, Telefone, Medalhas.

Use a ferramenta Composição (◆--*) para mostrar tudo que está embutido (ex: Campeonato para Edicao).

Use a ferramenta Dependência (-->) para mostrar todas as referências de ID (ex: de Resultado para Pessoas).

Preencha os atributos (nome: string, etc.) dentro de cada classe.

Seguindo essa lógica, você terá um diagrama lógico não relacional claro, representando perfeitamente o seu modelo MongoDB.









um exemplo de um modelo nao-relacional (img 1) que antes era um relacional (img 2)

Pelo que vejo muda a adicao de collections e as relacoes. EU quero q vc faça e me explique e descreva o do enunciado que te passei




Mostrar raciocínio
Perfeito, o exemplo que você mandou é exatamente a aplicação da técnica que conversamos. Ele deixa claro como representar visualmente um modelo de documentos.

Vamos então aplicar essa mesma lógica para o seu trabalho da Confederação de Natação. Vou descrever detalhadamente o que você precisa desenhar no Astah, explicando as decisões, para que você possa "fazer" o diagrama e entender cada parte dele.

Descrição Detalhada do Diagrama Lógico Não Relacional (MongoDB)
O seu banco de dados terá 4 collections principais. Cada uma será o ponto de partida para as nossas entidades.

1. Collection Pessoas
Esta collection centraliza tanto nadadores quanto treinadores.

Classe Principal: Pessoas

Atributos: _id: ObjectId (matrícula), nome: string, tipo: string, equipe_id: ObjectId, data_inscricao_cbda: date, sexo: char, data_nascimento: date, email: string, num_campeonatos_participados: int, formacao_academica: string, num_titulos_treinador: int.

Classe Estereótipo: Crie uma classe <<Collection>> Pessoas e ligue-a com uma seta simples à classe Pessoas.

Relações (Composição): A classe Pessoas "possui" seus telefones e seu quadro de medalhas. Eles são parte do documento principal.

Crie uma classe Telefone com atributos tipo: string, numero: string.

Ligue Pessoas a Telefone com uma Composição (◆). A cardinalidade é 1 no lado de Pessoas e 1..* no lado de Telefone.

Explicação: Isso modela o array de telefones. Cada Pessoa TEM um ou mais Telefones embutidos em seu documento.

Crie uma classe Medalhas com atributos ouro: int, prata: int, bronze: int.

Ligue Pessoas a Medalhas com uma Composição (◆). A cardinalidade é 1 em ambos os lados.

Explicação: Isso modela o objeto embutido de medalhas. Cada Pessoa TEM um único quadro de Medalhas.

Relações (Associação/Referência):

A classe Pessoas se conecta a Equipes.

Desenhe uma linha de Associação tracejada (- - ->) da classe Pessoas para a classe Equipes.

Explicação: Isso representa a referência equipe_id. O documento da pessoa não contém a equipe inteira, apenas o seu ID, "apontando" para a outra collection.

2. Collection Equipes
Esta collection armazena as equipes de forma independente.

Classe Principal: Equipes

Atributos: _id: ObjectId (código), nome: string, cidade_sede: string, data_fundacao: date, num_campeonatos_disputados: int, num_titulos_conquistados: int.

Classe Estereótipo: Crie uma classe <<Collection>> Equipes e ligue-a com uma seta simples à classe Equipes.

3. Collection Provas
Esta é a nossa collection "catálogo" de provas.

Classe Principal: Provas

Atributos: _id: ObjectId (código), estilo: string, distancia_metros: int, sexo: char.

Classe Estereótipo: Crie uma classe <<Collection>> Provas e ligue-a com uma seta simples à classe Provas.

4. Collection Campeonatos
Esta é a collection mais complexa, com muitos dados embutidos.

Classe Principal: Campeonatos

Atributos: _id: ObjectId (código), nome: string.

Classe Estereótipo: Crie uma classe <<Collection>> Campeonatos e ligue-a com uma seta simples à classe Campeonatos.

Relações (Composição Aninhada): Aqui vamos criar a cadeia de documentos embutidos.

Crie uma classe Edicao (com atributos ano, cidade_sede, etc.).

Ligue Campeonatos a Edicao com Composição (◆), cardinalidade 1 para 0..*.

Crie uma classe ProvaDisputada (com atributo descricao: string, prova_id: ObjectId).

Ligue Edicao a ProvaDisputada com Composição (◆), cardinalidade 1 para 0..*.

Crie uma classe Recorde (com atributos tempo, data, nadador_id: ObjectId).

Ligue ProvaDisputada a Recorde com Composição (◆), cardinalidade 1 para 1.

Crie uma classe Bateria (com atributos num_bateria, tipo, data).

Ligue ProvaDisputada a Bateria com Composição (◆), cardinalidade 1 para 0..*.

Crie uma classe Resultado (com atributos nadador_id: ObjectId, tempo, lugar_chegada, status).

Ligue Bateria a Resultado com Composição (◆), cardinalidade 1 para 0..*.

Relações (Associação/Referência dentro do aninhamento):

Da classe ProvaDisputada (que está embutida), desenhe uma Associação tracejada (- - ->) para a classe Provas.

Explicação: A prova disputada na edição referencia uma prova do catálogo.

Da classe Recorde (embutida), desenhe uma Associação tracejada (- - ->) para a classe Pessoas.

Explicação: O recorde referencia o nadador que o estabeleceu.

Da classe Resultado (embutida), desenhe uma Associação tracejada (- - ->) para a classe Pessoas.

Explicação: O resultado de uma bateria referencia o nadador que competiu.

Resumo da Explicação do Modelo
Por que essas 4 Collections? Porque Pessoas, Equipes, Provas e Campeonatos são as entidades raiz do nosso sistema. São os documentos que podemos querer consultar diretamente.

Por que tanta Composição (◆) em Campeonatos? Porque os dados de uma Edicao (suas provas, baterias e resultados) quase sempre serão lidos no contexto daquele campeonato. Embutir tudo em um único documento torna a leitura de "todos os resultados de uma prova" extremamente rápida e eficiente, pois o banco de dados não precisa buscar em vários lugares diferentes (como faria num modelo relacional com JOINs).

Por que Associação (- - ->) para Pessoas e Equipes? Porque uma Pessoa é uma entidade independente e completa. Se embutíssemos o documento inteiro do nadador dentro do resultado da prova, teríamos muita duplicação de dados. Se o email do nadador mudasse, teríamos que atualizar em todos os resultados de todas as provas que ele já nadou. Usando uma referência (o _id), mantemos os dados consistentes: a informação do nadador fica em um único lugar (na collection Pessoas) e o resto do sistema apenas "aponta" para ela.